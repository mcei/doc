### Цель

Разобрать реализацию пакета context из стандартной библиотеки Go и осветить его изменения в версии 1.21

### Что такое context

Контекстом называют реализацию интерфейса `Context` из пакета `context`.

```go
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key any) any
}
```

Контекст используется для того, чтобы передавать данные запросов, устанавливать таймауты и делать явную отмену в цепочке вложенных функций или горутин. Например, при взаимодействии с сервером, базой данных или API-интерфейсом.

Контекст создается на верхнем уровне приложения и передается в функции и горутины, для того, чтобы завершать выполнение, когда потребуется.

Есть два корневых (или родительских) контекста:
- `context.Background()`
- `context.TODO()`

Каждый является композицией из пустого контекста.

```go
type backgroundCtx struct{ emptyCtx }

type todoCtx struct{ emptyCtx }

...

func Background() Context {
	return backgroundCtx{}
}

func TODO() Context {
	return todoCtx{}
}
```

Корневой контекст никогда не отменяется, не имеет дэдлайна и не содержит значений.

По своей сути оба корневых контекста ничем не отличаются, но `context.TODO()` предполагается использовать только на время проектирования или эксперимента.

Принято передавать контекст явным образом в виде первого аргумента функции и использовать имя переменной `ctx`.

Пример функции из пакета `net/http`:

```go
func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {
	...
}

```

Новые контексты создаются на основе родительских.

### TODO добавить картинку с наследованием контекстов. draw.io

То есть мы добавляем в контекст информацию, оборачивая имеющийся контекст в одну из функций, возвращающую новый контекст. Это позволяет использовать контексты для передачи в глубокие слои кода.

```go
ctx, cancel := context.WithCancel(context.Background())
```

Здесь из функции `WithCancel` мы получаем новый контекст (копию родительского) и функцию отмены.

### Отмена

Предполагается использовать функцию отмены на том же уровне, где она была создана. Это назвается отменой вручную.
Пробрасывать и вызывать функцию отмены в другом месте считается анти-паттерном.

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // cancel when we are finished
```

Вызов функции отмены удаляет ссылку родителя на дочерний контекст и останавливает все связанные с ним таймеры. После этого сборщик мусора может собрать дочерние горутины, у которых больше нет связи с родительскими горутинами.

### Таймаут

Отмена контекста по времени может быть сделана при помощи функций `WithDeadline` и `WithTimeout`. Это позволяет ограничить максимальное время выполнения запроса.

Пример:

```go
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()
	return slowOperation(ctx)
}
```
Здесь функция `context.WithTimeout` принимает два аргумента: существующий контекст и `time.Duration`.

Контекст будет отменен по истечении таймаута автоматически, но также обязательно отменять контекст вручную при помощи `defer`, чтобы не допустить утечки ресурсов (памяти и горутин). Допустимо делать отмену контекста несколько раз. После первого вызова все последующие игнорируются.

Функция `context.WithDeadline` отличается тем, что вторым аргументом принимает `time.Time`. Если указать уже прошедший момент времени, то будет создан сразу отмененный контекст.

Метод `Deadline` экземпляра типа `context.Context` помогает узнать в какой момент времени произойдет отмена. Метод возвращает `time.Time` и `ok`. 

`Deadline` возвращает `ok=false`, когда deadline не установлен.

Также управлять отменой контекста помогают методы `Done` и `Err` экземпляра `context.Context`.

`Done` представляет канал типа `struct{}`, который закрывается при отмене контекста и возвращает нулевое значение (`nil`) при последующей попытке чтения из него.

Метод `Err` может возвращать три варианта значений:
- `nil` если контекст активен
- `context.Canceled` типа `error` в случае явной отмены контекста
- `context.DeadlineExceeded` в случае отмены по истечению времени

Методы экземпляра `context.Context` могут вызываться одновременно из нескольких горутин.

### Значения

Существует еще одна область применения контекста. В программе его можно использовать для передачи информации для конкретного запроса. Например, в тех случаях, когда невозможно передать данные явным образом через несколько промежуточных слоев.

В пакете имеется функция `WithValue` для добавления пары ключ-значение в контекст. Она принимает три аргумента: родительский контекст, ключ и значение.

Во избежание коллизий ключ не должен быть одним из встроенных типов и должен быть comparable.

```go
type favContextKey string 

key := favContextKey("language")
ctx := context.WithValue(context.Background(), key, "Go")

```
Получить значение ключа экземпляра `context.Context` можно воспользовавшись методом `Value`. Он принимает ключ и возвращает его значение. Если ключ не был найден, то возвращается нулевое значение пустого интерфейса (`nil`).

Пример:
```go
ctxValue := ctx.Value(key)
```

### Новое в 1.21


### Идиомы использования context

#### Do not store Contexts inside a struct type

В официальной документации Go есть настоятельная рекомендация не хранить контекст внутри структур, а вместо этого передавать его каждой функции явно.

Основная проблема здесь в том, что хранение контекста в структуре ведет к путанице и непредсказуемому поведению. 

Например, если в структуре несколько методов используют контекст, то невозможно выставить deadline или сделать отмену только для одного из методов. Такой код на продакшн-сервере становится опаснее, поскольку не каждый запрос адекватно и своевременно реагирует на отмену. Код сложнее отлаживать и тестировать.

При явной передаче контекста в функции пользователи могут в полной мере воспользоваться его расширяемостью, устанавливать для каждого вызова крайние сроки, отмену и данные.

#### Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions

Одно из преимуществ использования контекста — это возможность передачи данных на протяжении обработки задачи через несколько промежуточных слоев.

Это позволяет сделать функция WithValue из пакета context. Однако стоит взвешенно использовать эту функциональность. 

Если передавать в контексте опциональные аргументы функций, то это усложняет документирование в функциях. И может стать неявным, что функция ожидает какое-либо значение из контекста. Это делает API непонятным, усложняет чтение и поддержку кода, что в дальнейшем может привести к ошибкам.

Рекомендовано избегать хранения данных в контексте, если они могут быть переданы обычным аргументом в функции.

В контексте правильно передавать только значения, которые пересекают границы процессов и живут от начала и до конца обработки задачи. Например идентификатор пользователя или запроса для идентификации задачи при логировании.
