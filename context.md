Статья подробно описывает пакет context стандартной библиотеки Go. Хоть пакет и небольшой, в нём есть чему поучиться не только новичкам в Go, но и знатокам.
Например, можно поучиться проектированию интерфейсов, у пакета context образцовый интерфейс.
Можно узнать о распространённых приёмах Go, в реализации пакета их множество. 
Есть и новости, пакет развивается, в Go 1.21 в него будут добавлены новые функции.

## Обзор
Пакет context появился как [x/net/context](https://codereview.appspot.com/99330045) в 2014 году и быстро обрёл популярность. В 2016 году он был [добавлен](https://github.com/golang/go/issues/14660) в стандартную библиотеку Go 1.7.
С тех пор практически ни одно приложение на Go не обходится без его использования. Это не случайно, пакет ощутимо упрощает многие задачи.

### Что такое контекст

Контекстом называют интерфейс `Context` из пакета `context`.

```go
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key any) any
}
```
Контекст используется для того, чтобы:

* Устанавливать дедлайн по времени исполнения блока кода
* Оповещать об окончании исполнения блока кода
* Узнавать причину отмены контекста 
* Получать значения по ключу

Интерфейса достаточно для использования в любых местах, где код может "зависнуть". Это любое сетевое взаимодействие, а также долгие задачи, не выходящие за рамки процесса ОС.
Кроме того, контекст можно использовать для неявной передачи параметров в функции.

Все методы `context.Context` могут вызываться одновременно из нескольких горутин.

В Go принято передавать контекст в виде первого аргумента функции, имя аргумента обычно `ctx`.

Пример функции из пакета `net/http`:

```go
func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {
	...
}

```

### Корневой контекст 
Корневой контекст невозможно отменить, он не имеет дедлайна и не содержит значений.

Обычно корневой контекст создается в main() приложения и оборачивается в производный контекст с отменой, который затем передается в функции. 
Когда контекст отменяется в main(), отменяется и код в глубине стека вызовов. Это помогает реализовать корректное завершение работы процесса.

Есть две функции получения корневого контекста:
- `context.Background()`
- `context.TODO()`

Реализованы они очень просто:

```go
func Background() Context {
    return backgroundCtx{}
}

func TODO() Context {
    return todoCtx{}
}

...

type backgroundCtx struct{ emptyCtx }

type todoCtx struct{ emptyCtx }
```


`todoCtx` и `backgroundCtx` практически ничем не отличаются, но `context.TODO()` используется только на время проектирования или эксперимента.
`context.TODO()` пригождается, когда нужно вызвать функцию, требующую context.Context как аргумент, но в данный момент контекст не проброшен сверху по стеку вызовов.
Тогда нормально временно использовать `context.TODO()`, а отдельным MR-ом пробросить полноценный контекст, который можно отменять.

### Создание нового контекста

Все контексты за исключением корневых создаются на основе родительских контекстов.

Новый контекст расширяет родительский новой информацией. Например, в новый контекст можно положить ключ со значением, при этом не модифицируя родительский контекст.

Для создания новых контекстов в пакете предусмотрены функции `WithCancel`, `WithDeadline`, `WithTimeout`, `WithValue` и `WithoutCancel`.

#### WithCancel
```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // cancel when we are finished
```

`WithCancel` возвращает новый контекст и функцию отмены. Новый контекст хранит ссылку на родительский контекст.

Функцию отмены нужно вызывать на том же уровне, где она была создана. Это называется отменой вручную.
Вызывать функцию отмены в другом месте считается анти-паттерном.

Вызов cancel закрывает канал, возвращаемый методом Done() контекста.
Также канал Done() дочернего контекста закрывается, если закрывается канал Done() родительского контекста.

#### WithDeadline и WithTimeout
Автоматическую отмену контекста по времени можно сделать при помощи функций `WithDeadline` и `WithTimeout`. Они позволяют ограничить максимальное время выполнения блока кода.

Пример:

```go
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
	ctx, cancel := context.WithTimeout(ctx, time.Second)
	defer cancel()
	return slowOperation(ctx)
}
```
Здесь функция `context.WithTimeout` принимает два аргумента: существующий контекст и `time.Duration`.

Контекст будет отменен по истечении таймаута автоматически, но также обязательно отменять контекст вручную при помощи `defer`, чтобы не допустить утечки ресурсов (памяти и горутин).
Допустимо делать отмену контекста несколько раз. После первого вызова все последующие игнорируются.

Функция `context.WithDeadline` отличается тем, что вторым аргументом принимает `time.Time`. Если указать уже прошедший момент времени, то будет создан сразу отмененный контекст.

Метод `Deadline` экземпляра типа `context.Context` помогает узнать в какой момент времени произойдет отмена. Метод возвращает `time.Time` и `ok`. 

`Deadline` возвращает `ok=false`, когда deadline не установлен.

#### WithValue
В тех случаях, когда невозможно передать данные явным образом через несколько промежуточных функций, можно использовать `WithValue`.

`WithValue` добавляет пару ключ-значение в контекст. Она принимает три аргумента: родительский контекст, ключ и значение.

Во избежание коллизий ключ не должен быть одним из встроенных типов и должен быть comparable.

```go
type favContextKey string 

key := favContextKey("language")
ctx := context.WithValue(context.Background(), key, "Go")

```
Получить значение можно методом `Value`. Он принимает ключ и возвращает его значение. Если ключ не был найден, возвращается `nil`.

Пример:
```go
ctxValue := ctx.Value(key)
```

### Обработка ошибок
Узнавать об отмене контекста помогают методы `Done` и `Err` экземпляра `context.Context`.

`Done` представляет канал типа `struct{}`, который закрывается при отмене контекста и возвращает нулевое значение (`nil`) при последующей попытке чтения из него.

Метод `Err` может возвращать три варианта значений:
- `nil` если контекст активен
- `context.Canceled` типа `error` в случае явной отмены контекста
- `context.DeadlineExceeded` в случае отмены по истечению времени


## Новое в 1.21

### WithoutCancel

В Go 1.21 [добавлена](https://github.com/golang/go/issues/40221) функция `WithoutCancel`.

`WithoutCancel` возвращает копию родительского контекста, которая не будет отменена при отмене родительского контекста. 

Полученный контекст не возвращает Deadline или Err. Его Done канал является nil.

```go
func WithoutCancel(parent Context) Context {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	return withoutCancelCtx{parent}
}

type withoutCancelCtx struct {
	c Context
}

func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (withoutCancelCtx) Done() <-chan struct{} {
	return nil
}

func (withoutCancelCtx) Err() error {
	return nil
}
```

WithoutCancel можно использовать в следующих довольно частых сценариях:
  - при обработке rollback/cleanup операций в контексте какого-либо события (например, обработка HTTP-запроса). Операции должны продолжиться несмотря на отмену самого события (например, клиент ушёл или наступил таймаут)
  - при обработке длительных операций, запущенных каким-либо событием (например, HTTP-запросом). Событие можно пометить как обработанное не дожидаясь завершения длительной операции.

### AfterFunc
В Go 1.21 [добавлена](https://github.com/golang/go/issues/57928) новая функция AfterFunc.

Иногда нужно отменить блокирующую функцию, которая поддерживает прерывание, но не через механизм отмены контекста. До Go 1.21 это делалось сложно и неэффективно.
Например, можно прервать чтение или запись в net.Conn или ожидание на sync.Cond, но это делалось через запуск отдельной горутины. Горутина ждёт когда отменится контекст, а затем прерывает блокирующую функцию.
Запуск новых горутин достаточно эффективен, но запуск новой горутины - это большие накладные расходы, если операция очень лёгкая.

AfterFunc позволяет зарегистрировать функцию, которая называется при отмене контекста.

```go
func AfterFunc(ctx Context, f func()) (stop func() bool)
```

AfterFunc принимает функцию f, которая будет выполнена после того, как контекст будет отменен (в том числе после истечения таймаута). Если контекст уже завершён, функция будет запущена сразу же.

Выполнение f происходит в отдельной горутине. Множественные вызовы AfterFunc выполняются независимо друг от друга.

AfterFunc возвращает stop-функцию. Вызов stop-функции разрывает ассоциацию f с контекстом.

stop-функция возвращает false если контекст уже в состоянии Done и f уже была запущена или f уже была остановлена.
stop-функция возвращает true, f была прервана.

stop-функция не дожидается пока f будет завершена, поэтому если нужно контролировать состояние, то лучше явно коммуницировать с f.

### Оптимизация инициализации пакета
Рантайм Go с каждой версией становится лучше. Иногда для оптимизации рантайма требуются изменения в стандартной библиотеке.

Пакет context эти оптимизации [не обошли стороной](https://github.com/golang/go/issues/26775).

До Go 1.21 функции `Background` и `TODO` возвращали заранее заготовленные экземпляры контекста.
```go
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)

func Background() Context {
	return background
}
```

В версии 1.21 `Background` и `TODO` контексты стали разными типами, встраивающими пустой контекст.

```go
type backgroundCtx struct{ emptyCtx }

...

type todoCtx struct{ emptyCtx }

```
То есть теперь нет глобальных переменных и инициализация рантайма проходит чуть-чуть быстрее.

### Идиомы использования context

#### Do not store Contexts inside a struct type

В официальной документации Go есть настоятельная рекомендация не хранить контекст внутри структур, а вместо этого передавать его каждой функции явно.

Основная проблема здесь в том, что хранение контекста в структуре ведет к путанице и непредсказуемому поведению. 

Например, если в структуре несколько методов используют контекст, то невозможно выставить deadline или сделать отмену только для одного из методов. Такой код на продакшн-сервере становится опаснее, поскольку не каждый запрос адекватно и своевременно реагирует на отмену. Код сложнее отлаживать и тестировать.

При явной передаче контекста в функции пользователи могут в полной мере воспользоваться его расширяемостью, устанавливать для каждого вызова крайние сроки, отмену и данные.

#### Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions

Одно из преимуществ использования контекста — это возможность передачи данных на протяжении обработки задачи через несколько промежуточных слоев.

Это позволяет сделать функция WithValue из пакета context. Однако стоит взвешенно использовать эту функциональность. 

Если передавать в контексте опциональные аргументы функций, то это усложняет документирование в функциях. И может стать неявным, что функция ожидает какое-либо значение из контекста. Это делает API непонятным, усложняет чтение и поддержку кода, что в дальнейшем может привести к ошибкам.

Рекомендовано избегать хранения данных в контексте, если они могут быть переданы обычным аргументом в функции.

В контексте правильно передавать только значения, которые пересекают границы процессов и живут от начала и до конца обработки задачи. Например идентификатор пользователя или запроса для идентификации задачи при логировании.


#### Реализации контекста

В пакете имеются следующие типы, реализующие интерфейс Context:
- emptyCtx
- cancelCtx
- timerCtx
- valueCtx
- stopCtx
- afterFuncCtx
- withoutCancelCtx
- backgroundCtx
- todoCtx


Большинство типов ассоциированы с функциями, создающими контекст.

Тип emptyCtx встроен в типы backgroundCtx и todoCtx.

Тип cancelCtx встроен в типы timerCtx и afterFuncCtx.

![image](https://github.com/mcei/doc/assets/57292616/9a5fb7d6-b018-4bf3-9f45-2cc21a652889)


#### Embedding

Go предлагает механизм встраивания (embedding) в качестве альтернативы традиционному механизму наследования.

Разберем пример эмбеддинга из библиотеки Context.

`type backgroundCtx struct{ emptyCtx }`

Тип emptyCtx встроен в тип backgroundCtx и является для него основой.

У emptyCtx [реализованы]([url](https://github.com/golang/go/blob/master/src/context/context.go#L179-L193)) методы Deadline(), Done(), Err(), Value(), а backgroundCtx реализует лишь свой метод String. При этом, эмбеддинг emptyCtx делает все его методы доступными для backgroundCtx.


#### context.AfterFunc

Рассмотрим реализацию AfterFunc:
```go
func AfterFunc(ctx Context, f func()) (stop func() bool) {
	a := &afterFuncCtx{
		f: f,
	}
	a.cancelCtx.propagateCancel(ctx, a)
	return func() bool {
		stopped := false
		a.once.Do(func() {
			stopped = true
		})
		if stopped {
			a.cancel(true, Canceled, nil)
		}
		return stopped
	}
}
```

Рассмотрим использование sync.Once.Do в context.AfterFunc

AfterFuncCtx встраивает объект sync.Once

```go
type afterFuncCtx struct {
	cancelCtx
	once sync.Once
	f    func()
}
```
Функция once.Do вызывает функцию f только в том случае, если она вызывается в первый раз для текущего инстанса Once.
Если once.Do(f) вызывается несколько раз, то только первый вызов выполнит f.

То есть once.Do(f) либо вызывает f, либо предотвращает ее повторный вызов.

Так сделано для того, чтобы при отмене контекста из разных горутин, AfterFunc выполнилась только единожды.

#### Reusable closed channel

Разберем использование закрытого канала в пакете context.

```go
var closedchan = make(chan struct{})

func init() {
	close(closedchan)
}
```

При инициализации пакета создается глобальная переменная `closedchan`. 

Чтобы закрыть канал, используется функция `init()`. Это своеобразный механизм, который сообщает компилятору какой код должен быть выполнен перед импортом пакета. Код содержащийся в `init()` исполняется только один раз.

Далее закрытый канал используется для изменения и проверки состояния Done при отмене контекста.

```go
if done == closedchan {
	...
}
```

Преимущество такой реализации в том, что переиспользуется глобальная переменная, а не создаются отдельные переменные при необходимости.

### Итог

Мы рассмотрели использование и основные концепты пакета context, а также осветили изменения в 1.21.

### Вывод

На примере стандартной библиотеки можно ближе познакомиться с различными идиомами принятыми в Go.
