Статья подробно описывает пакет context стандартной библиотеки Go.

Хоть пакет и небольшой, в нём есть чему поучиться не только новичкам в Go, но и знатокам.
Например, можно поучиться проектированию интерфейсов, у пакета context образцовый интерфейс.
Можно узнать о распространённых приёмах Go, в реализации пакета их множество.
Есть и новости, пакет развивается, в Go 1.21 в него будут добавлены новые функции.

## Обзор
Пакет context появился как [x/net/context](https://codereview.appspot.com/99330045) в 2014 году и быстро обрёл популярность. В 2016 году он был [добавлен](https://github.com/golang/go/issues/14660) в стандартную библиотеку Go 1.7.
С тех пор практически ни одно приложение на Go не обходится без его использования. Это не случайно, пакет ощутимо упрощает многие задачи.

### Что такое контекст

Контекстом называют интерфейс `Context` из пакета `context`.

```go
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key any) any
}
```
Контекст используется для того, чтобы:

* Устанавливать дедлайн по времени исполнения блока кода
* Оповещать об окончании исполнения блока кода
* Узнавать причину отмены контекста
* Получать значения по ключу

Интерфейса достаточно для использования в любых местах, где код может "зависнуть". Это любое сетевое взаимодействие, а также долгие задачи, не выходящие за рамки процесса ОС.
Кроме того, контекст можно использовать для неявной передачи параметров в функции.

Все методы `context.Context` могут вызываться одновременно из нескольких горутин.

В Go принято передавать контекст в виде первого аргумента функции, имя аргумента обычно `ctx`.

Пример функции из пакета `net/http`:

```go
func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {
	...
}

```

### Корневой контекст
Корневой контекст невозможно отменить, он не имеет дедлайна и не содержит значений.

Обычно корневой контекст создается в main() приложения и оборачивается в производный контекст с отменой, который затем передается в функции.
Когда контекст отменяется в main(), отменяется и код в глубине стека вызовов. Это помогает реализовать корректное завершение работы процесса.

Есть две функции получения корневого контекста:
- `context.Background()`
- `context.TODO()`

Реализованы они очень просто:

```go
func Background() Context {
    return backgroundCtx{}
}

func TODO() Context {
    return todoCtx{}
}

...

type backgroundCtx struct{ emptyCtx }

type todoCtx struct{ emptyCtx }
```


`todoCtx` и `backgroundCtx` практически ничем не отличаются, но `context.TODO()` используется только на время проектирования или эксперимента.
`context.TODO()` пригождается, когда нужно вызвать функцию, требующую context.Context как аргумент, но в данный момент контекст не проброшен сверху по стеку вызовов.
Тогда нормально временно использовать `context.TODO()`, а отдельным MR-ом пробросить полноценный контекст, который можно отменять.

### Создание нового контекста

Все контексты за исключением корневых создаются на основе родительских контекстов.

Новый контекст расширяет родительский новой информацией. Например, в новый контекст можно положить ключ со значением, при этом не модифицируя родительский контекст.

Для создания новых контекстов в пакете предусмотрены функции `WithCancel`, `WithDeadline`, `WithTimeout`, `WithValue` и `WithoutCancel`.

#### WithCancel
```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // cancel when we are finished
```

`WithCancel` возвращает новый контекст и функцию отмены. Новый контекст хранит ссылку на родительский контекст.

Функцию отмены нужно вызывать на том же уровне, где она была создана. Это называется отменой вручную.
Вызывать функцию отмены в другом месте считается анти-паттерном.

Вызов cancel закрывает канал, возвращаемый методом Done() контекста.
Также канал Done() дочернего контекста закрывается, если закрывается канал Done() родительского контекста.

#### WithDeadline и WithTimeout
Автоматическую отмену контекста по времени можно сделать при помощи функций `WithDeadline` и `WithTimeout`. Они позволяют ограничить максимальное время выполнения блока кода.

Пример:

```go
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
	ctx, cancel := context.WithTimeout(ctx, time.Second)
	defer cancel()
	return slowOperation(ctx)
}
```
Здесь функция `context.WithTimeout` принимает два аргумента: существующий контекст и `time.Duration`.

Контекст будет отменен по истечении таймаута автоматически, но также обязательно отменять контекст вручную при помощи `defer`, чтобы не допустить утечки ресурсов (памяти и горутин).
Допустимо делать отмену контекста несколько раз. После первого вызова все последующие игнорируются.

Функция `context.WithDeadline` отличается тем, что вторым аргументом принимает `time.Time`. Если указать уже прошедший момент времени, то будет создан сразу отмененный контекст.

Метод `Deadline` экземпляра типа `context.Context` помогает узнать в какой момент времени произойдет отмена. Метод возвращает `time.Time` и `ok`.

`Deadline` возвращает `ok=false`, когда deadline не установлен.

#### WithValue
В тех случаях, когда невозможно передать данные явным образом через несколько промежуточных функций, можно использовать `WithValue`.

`WithValue` добавляет пару ключ-значение в контекст. Функция принимает три аргумента: родительский контекст, ключ и значение.

Во избежание коллизий ключ не должен быть одним из встроенных типов и должен быть comparable.

```go
type favContextKey string

key := favContextKey("language")
ctx := context.WithValue(context.Background(), key, "Go")

```
Получить значение можно методом `Value`. Он принимает ключ и возвращает его значение. Если ключ не был найден, возвращается `nil`.

Пример:
```go
ctxValue := ctx.Value(key)
```

### Обработка ошибок
Узнавать об отмене контекста помогают методы `Done` и `Err` экземпляра `context.Context`.

`Done` представляет канал типа `struct{}`, который закрывается при отмене контекста и возвращает нулевое значение (`nil`) при последующей попытке чтения из него.

Метод `Err` может возвращать три варианта значений:
- `nil` если контекст активен
- `context.Canceled` типа `error` в случае явной отмены контекста
- `context.DeadlineExceeded` в случае отмены по истечению времени


## Новое в 1.21

### WithoutCancel

В Go 1.21 [добавлена](https://github.com/golang/go/issues/40221) функция `WithoutCancel`.

`WithoutCancel` возвращает копию родительского контекста, которая не будет отменена при отмене родительского контекста.

Полученный контекст не возвращает Deadline или Err. Его Done канал является nil.

```go
func WithoutCancel(parent Context) Context {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	return withoutCancelCtx{parent}
}

type withoutCancelCtx struct {
	c Context
}

func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (withoutCancelCtx) Done() <-chan struct{} {
	return nil
}

func (withoutCancelCtx) Err() error {
	return nil
}
```

WithoutCancel можно использовать в следующих довольно частых сценариях:
  - при обработке rollback/cleanup операций в контексте какого-либо события (например, обработка HTTP-запроса). Операции должны продолжиться несмотря на отмену самого события (например, клиент ушёл или наступил таймаут)
  - при обработке длительных операций, запущенных каким-либо событием (например, HTTP-запросом). Событие можно пометить как обработанное не дожидаясь завершения длительной операции.

### AfterFunc
В Go 1.21 [добавлена](https://github.com/golang/go/issues/57928) новая функция AfterFunc.

Иногда нужно отменить блокирующую функцию, которая поддерживает прерывание, но не через механизм отмены контекста. До Go 1.21 это делалось сложно и неэффективно.
Например, можно прервать чтение или запись в net.Conn или ожидание на sync.Cond, но это делалось через запуск отдельной горутины. Горутина ждёт когда отменится контекст, а затем прерывает блокирующую функцию.
Запуск новых горутин достаточно эффективен, но запуск новой горутины — это большие накладные расходы, если операция очень лёгкая.

AfterFunc позволяет зарегистрировать функцию, которая вызывается при отмене контекста.

```go
func AfterFunc(ctx Context, f func()) (stop func() bool)
```

AfterFunc принимает функцию f, которая будет выполнена после того, как контекст будет отменен (в том числе после истечения таймаута). Если контекст уже завершён, функция будет запущена сразу же.

Выполнение f происходит в отдельной горутине. Множественные вызовы AfterFunc выполняются независимо друг от друга.

AfterFunc возвращает stop-функцию. Вызов stop-функции разрывает ассоциацию f с контекстом.

Stop-функция возвращает false если контекст уже в состоянии Done и f уже была запущена или f уже была остановлена.
Stop-функция возвращает true, f была прервана.

Stop-функция не дожидается пока f будет завершена, поэтому если нужно контролировать состояние, то лучше явно коммуницировать с f.

### Оптимизация инициализации пакета
Рантайм Go с каждой версией становится лучше. Иногда для оптимизации рантайма требуются изменения в стандартной библиотеке.

Пакет context эти оптимизации [не обошли стороной](https://github.com/golang/go/issues/26775).

До Go 1.21 функции `Background` и `TODO` возвращали заранее заготовленные экземпляры контекста.
```go
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)

func Background() Context {
	return background
}
```

В версии 1.21 `Background` и `TODO` контексты стали разными типами, встраивающими пустой контекст.

```go
type backgroundCtx struct{ emptyCtx }
type todoCtx struct{ emptyCtx }

...

func Background() Context {
    return backgroundCtx{}
}
```
То есть теперь нет глобальных переменных и инициализация рантайма проходит чуть-чуть быстрее.

## Особенности использования контекста

### Do not store Contexts inside a struct type

Документация пакета context настоятельно рекомендует не хранить контекст внутри структур. Вместо этого нужно явно передавать контекст в функции, отдельным аргументом.

Хранение контекста в структуре ведет к путанице и непредсказуемому поведению.
Например, если в структуре несколько методов используют контекст, то невозможно выставить deadline или сделать отмену только для одного из методов.
Код, использующий такую структуру, сложнее отлаживать и тестировать.
В первую очередь потому что для аккуратного использования методов структуры нужно прочитать все реализации методов структуры.
То, что нужно погружаться в реализацию при использовании каких-то методов может означать только одно: при проектировании нарушены базовые принципы абстракции и инкапсуляции.

При явной передаче контекста в функции пользователи могут в полной мере воспользоваться его расширяемостью, устанавливать для каждого вызова дедлайн, отмену и значения ключей.

### Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions

Одно из преимуществ использования WithValue — это возможность неявной передачи данных через несколько промежуточных функций.
Однако стоит взвешенно использовать эту функциональность.

Если передавать в контексте опциональные аргументы функций, это усложняет документирование функций.
Довольно странно писать, что функция ожидает в контексте определённый ключ. Такие вещи должны проверяться компилятором, а не людьми при написании кода. Иначе нет гарантий отсутствия ошибок.
То есть для опциональных аргументов лучше использовать обычные аргументы функций с нулевыми значениями.

В контексте правильно передавать только значения, которые пересекают границы процессов и живут от начала и до конца обработки задачи.
Например, идентификатор пользователя или запроса хорошо ложится в контекст. В любой функции, использующейся по ходу обработки запроса идентификатор можно залогировать или передать во внешнюю систему.
Логгер тоже хорошо ложится в контекст. Это особенно актуально для структурированного логирования.


## Особенности реализации контекста

В пакете имеются следующие типы, реализующие интерфейс Context:
- emptyCtx
- backgroundCtx
- todoCtx
- cancelCtx
- timerCtx
- afterFuncCtx
- valueCtx
- withoutCancelCtx
- stopCtx

Большинство типов ассоциированы с функциями, создающими контекст.

![image](https://github.com/mcei/doc/assets/57292616/97de2d15-fab9-4bb0-8884-4d63e620033e)


### Embedding

Пакет context активно использует механизм встраивания (embedding) в качестве альтернативы традиционному механизму наследования.

Например, `backgroundCtx` реализован как `type backgroundCtx struct{ emptyCtx }`

Тип emptyCtx встроен в тип backgroundCtx.

У emptyCtx [реализованы]([url](https://github.com/golang/go/blob/master/src/context/context.go#L179-L193)) методы Deadline(), Done(), Err(), Value(), а backgroundCtx реализует лишь свой метод String.
При этом все публичные методы emptyCtx автоматически доступны при обращении к backgroundCtx.


### Реализация AfterFunc

Рассмотрим реализацию AfterFunc:
```go
func AfterFunc(ctx Context, f func()) (stop func() bool) {
	a := &afterFuncCtx{
		f: f,
	}
	a.cancelCtx.propagateCancel(ctx, a)
	return func() bool {
		stopped := false
		a.once.Do(func() {
			stopped = true
		})
		if stopped {
			a.cancel(true, Canceled, nil)
		}
		return stopped
	}
}

...

type afterFuncCtx struct {
	cancelCtx
	once sync.Once
	f    func()
}
```

AfterFuncCtx хранит объект sync.Once.

a.once.Do() вызывает `func() { stopped = true }` только в том случае, если она вызывается в первый раз.

Do() потокобезопасна, то есть Do() можно одновременно вызвать из нескольких горутин. Только одна из горутин выполнит f.

Так сделано для того, чтобы при отмене контекста из разных горутин AfterFunc выполнилась только один раз.

### Reusable closed channel

В пакете context есть интересная глобальная переменная closedchan.

```go
var closedchan = make(chan struct{})

func init() {
	close(closedchan)
}
```

Этот код создаёт глобальный закрытый канал на старте приложения, импортирующего пакет context.

Далее закрытый канал используется для изменения и проверки состояния Done при отмене контекста.

Для начала ознакомимся с реализацией cancelCtx (такую структуру создаёт WithCancel):
```go
type cancelCtx struct {
	Context               // Родительский контекст
	done     atomic.Value // Хранит chan struct{}, канал закрывается на первом вызове cancel()
	... // Остальные поля
}
```

Вот что происходит при вызове cancelCtx.Done() (схематично, в реализации ещё есть мьютекс):
```go
func (c *cancelCtx) Done() <-chan struct{} {
	d := c.done.Load() // Загружаем значение атомарной переменной
	if d == nil { // Если значение не установлено, создаём новый канал и сохраняем его
        	d = make(chan struct{})
        	c.done.Store(d)
	}

	return d.(chan struct{})
}
```
При вызове cancel() используем closedchan:

```go
func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) {
	...
	d, _ := c.done.Load().(chan struct{}) // Загружаем содержимое атомарной переменной
	if d == nil {
		c.done.Store(closedchan) // Если Done() ещё никто не вызывал, записываем заранее заготовленный закрытый канал
	} else {
		close(d) // Если Done() вызывали, канал был создан, нужно его закрыть
	}
	...
}
```

Также используем closedchan для проверки того, что родительский контекст закрыт:
```go
func parentCancelCtx(parent Context) (*cancelCtx, bool) {
	done := parent.Done()
	if done == closedchan || done == nil { // Удобно, потому что для проверки канала на закрытость не нужно его читать
		return nil, false
	}
}
```

Такая реализация позволяет не создавать лишние каналы и немного оптимизирует отмену контекстов.


### Как cancelCtx отменяет дочерние контексты

Каждый контекст связан со своим родительским контекстом. Поэтому при отмене родительского контекста все дочерние будут также отменены.

Однако, при отмене дочернего контекста его родительский контекст не будет отменен. И более того, родительскому контексту никак не сообщается, что дочерние контексты были отменены.

Функция propagateCancel делает отмену дочерних контекстов при отмене родительского. И позволяет определять более сложные сценарии отмены задач, зависящих от корневого контекста. И также она предотвращает отмену родительского контекста, при отмене дочерних.

Если родительский контекст уже отменен, то она запускает отмену всех дочерних контекстов при помощи функции `cancel`.

Функция `cancel` закрывает Done-канал, отменяет дочерние контексты и опционально удаляет связь между родительским и дочерним контекстами. Также при первой отмене она устанавливат причину отмены.

### Особенности реализации ctx.Value()

Получить значение контекста можно при помощи метода Value. Он принимает ключ и возвращает его значение.

Если ключ не существует в текущем контексте, то поиск будет рекурсивно подниматься по дереву контекстов пока не будет найден корневой контекст. Если значение не найдено, то возвращается nil.
  
Особенность реализации здесь в том, что поиск значения происходит во всех родительских контекстах, что значительно упрощает его получение. При этом неважно насколько глубоко вложенным является контекст с искомым значением.

Следует избегать ситуаций с созданием нескольких контекстов с одинаковыми ключами с помощью WithValue(). В этом случае ctx.Value() будет возвращать ближайшее к ctx значение; так как значения в родительских контекстах будут не перезаписаны, а скрыты.

Также стоит отметить, что при большой вложенности линейный перебор связного списка контекстов может быть довольно затратным. Поэтому существует [рекомендация](https://github.com/golang/go/issues/33283) не использовать контекст как хранилище данных. В том числе, есть известная [проблема](https://github.com/golang/go/issues/47292), что когда цепочка вложенных контекстов достигает определенного размера, то это провоцирует довольно дорогостоющую операцию по изменению размера стека горутин, что может отражаться на производительности.

Для менее затратного получения значений из большой цепочки вложенных контекстов может быть использована библиотека [zerosnake0/goctx](https://github.com/zerosnake0/goctx)


## Итог

Допустим, ты хочешь научиться мастерски владеть инструментом.
Стратегий достижения мастерства множество, но одна из самых простых — это учиться у действующих мастеров.
Отлично, если это по совместительству мастера, которые создали инструмент. Ещё лучше, если это мастера, которые создали этот инструмент под себя.
Да, скорее всего, в последнем случае инструмент не будет выглядеть модно, но зато он будет качественно решать поставленные перед ним задачи.

Go тоже инструмент. Ясно, что авторы Go создают универсальный инструмент, причём в первую очередь для своих задач. Поэтому реализацию языка и стандартной библиотеки можно и нужно [читать](https://github.com/golang/go/tree/master/src).
Нужно читать не потому что можно использовать какие-нибудь особенности реализации, а потому что реализация хорошо написана и там действительно есть чему поучиться.

Эта статья предлагает поучиться Go на примере стандартного пакета context. Выбор пакета не случаен, в нём хорошо выражена философия Go.
