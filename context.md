### Цель

Разобрать реализацию пакета context из стандартной библиотеки Go и осветить его изменения в версии 1.21

### Что такое context

Контекстом называют реализацию интерфейса `Context` из пакета `context`.

```go
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key any) any
}
```

Контекст используется для того, чтобы передавать данные запросов, устанавливать таймауты и делать явную отмену в цепочке вложенных функций или горутин. Например, при взаимодействии с сервером, базой данных или API-интерфейсом.

Контекст создается на верхнем уровне приложения и передается в функции и горутины, для того, чтобы завершать выполнение, когда потребуется.

Есть два корневых (или родительских) контекста:
- `context.Background()`
- `context.TODO()`

Каждый является композицией из пустого контекста.

```go
type backgroundCtx struct{ emptyCtx }

type todoCtx struct{ emptyCtx }

...

func Background() Context {
	return backgroundCtx{}
}

func TODO() Context {
	return todoCtx{}
}
```

Корневой контекст никогда не отменяется, не имеет дэдлайна и не содержит значений.

По своей сути оба корневых контекста ничем не отличаются, но `context.TODO()` предполагается использовать только на время проектирования или эксперимента.

Принято передавать контекст явным образом в виде первого аргумента функции и использовать имя переменной `ctx`.

Пример функции из пакета `net/http`:

```go
func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {
	...
}

```

Новые контексты создаются на основе родительских.

![image](https://github.com/mcei/doc/assets/57292616/ded5ef07-6ff1-4b81-ab5a-aecbf1180135)

То есть мы добавляем в контекст информацию, оборачивая имеющийся контекст в одну из функций, возвращающую новый контекст. Это позволяет использовать контексты для передачи в глубокие слои кода.

```go
ctx, cancel := context.WithCancel(context.Background())
```

Здесь из функции `WithCancel` мы получаем новый контекст (копию родительского) и функцию отмены.

### Отмена

Предполагается использовать функцию отмены на том же уровне, где она была создана. Это назвается отменой вручную.
Пробрасывать и вызывать функцию отмены в другом месте считается анти-паттерном.

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // cancel when we are finished
```

Вызов функции отмены удаляет ссылку родителя на дочерний контекст и останавливает все связанные с ним таймеры. После этого сборщик мусора может собрать дочерние горутины, у которых больше нет связи с родительскими горутинами.

### Таймаут

Отмена контекста по времени может быть сделана при помощи функций `WithDeadline` и `WithTimeout`. Это позволяет ограничить максимальное время выполнения запроса.

Пример:

```go
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()
	return slowOperation(ctx)
}
```
Здесь функция `context.WithTimeout` принимает два аргумента: существующий контекст и `time.Duration`.

Контекст будет отменен по истечении таймаута автоматически, но также обязательно отменять контекст вручную при помощи `defer`, чтобы не допустить утечки ресурсов (памяти и горутин). Допустимо делать отмену контекста несколько раз. После первого вызова все последующие игнорируются.

Функция `context.WithDeadline` отличается тем, что вторым аргументом принимает `time.Time`. Если указать уже прошедший момент времени, то будет создан сразу отмененный контекст.

Метод `Deadline` экземпляра типа `context.Context` помогает узнать в какой момент времени произойдет отмена. Метод возвращает `time.Time` и `ok`. 

`Deadline` возвращает `ok=false`, когда deadline не установлен.

Также управлять отменой контекста помогают методы `Done` и `Err` экземпляра `context.Context`.

`Done` представляет канал типа `struct{}`, который закрывается при отмене контекста и возвращает нулевое значение (`nil`) при последующей попытке чтения из него.

Метод `Err` может возвращать три варианта значений:
- `nil` если контекст активен
- `context.Canceled` типа `error` в случае явной отмены контекста
- `context.DeadlineExceeded` в случае отмены по истечению времени

Методы экземпляра `context.Context` могут вызываться одновременно из нескольких горутин.

### Значения

Существует еще одна область применения контекста. В программе его можно использовать для передачи информации для конкретного запроса. Например, в тех случаях, когда невозможно передать данные явным образом через несколько промежуточных слоев.

В пакете имеется функция `WithValue` для добавления пары ключ-значение в контекст. Она принимает три аргумента: родительский контекст, ключ и значение.

Во избежание коллизий ключ не должен быть одним из встроенных типов и должен быть comparable.

```go
type favContextKey string 

key := favContextKey("language")
ctx := context.WithValue(context.Background(), key, "Go")

```
Получить значение ключа экземпляра `context.Context` можно воспользовавшись методом `Value`. Он принимает ключ и возвращает его значение. Если ключ не был найден, то возвращается нулевое значение пустого интерфейса (`nil`).

Пример:
```go
ctxValue := ctx.Value(key)
```

### Новое в 1.21

#### Оптимизация инициализации контекста

Изменение касается создания корневых контекстов.

Ранее корневые контексты `Background` и `TODO` были экземплярами пустого контекста c разными адресами.

```go
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
```

В версии 1.21 `Background` и `TODO` контексты стали разными типами, встраивающими пустой контекст.

```go
type backgroundCtx struct{ emptyCtx }

...

type todoCtx struct{ emptyCtx }

```

Это изменение сделано в рамках оптимизации по снижению использования CPU и памяти при инициализации пакета `context`.


#### WithoutCancel

Тип WithoutCancel реализует интерфейс Context

WithoutCancel возвращает копию родительского контекста, которая не будет отменена при отмене родительского контекста. 

Полученный контекст не возвращает Deadline или Err. Его Done канал является nil. Однако, полученный контекст сохраняет родительские значения.

```go

func WithoutCancel(parent Context) Context {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	return withoutCancelCtx{parent}
}

type withoutCancelCtx struct {
	c Context
}

func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (withoutCancelCtx) Done() <-chan struct{} {
	return nil
}

func (withoutCancelCtx) Err() error {
	return nil
}

```

Эта функциональность может найти применение в следующих довольно частых сценариях:
  - при обработке rollback/cleanup операций в контексте какого-либо события (например, HTTP-запрос), которые должны продолжиться несмотря на отмену самого события
  - при обработке длительных операций, запущенных каким-либо событием, которое завершается не дожидаясь завершения длительной операции.


### Идиомы использования context

#### Do not store Contexts inside a struct type

В официальной документации Go есть настоятельная рекомендация не хранить контекст внутри структур, а вместо этого передавать его каждой функции явно.

Основная проблема здесь в том, что хранение контекста в структуре ведет к путанице и непредсказуемому поведению. 

Например, если в структуре несколько методов используют контекст, то невозможно выставить deadline или сделать отмену только для одного из методов. Такой код на продакшн-сервере становится опаснее, поскольку не каждый запрос адекватно и своевременно реагирует на отмену. Код сложнее отлаживать и тестировать.

При явной передаче контекста в функции пользователи могут в полной мере воспользоваться его расширяемостью, устанавливать для каждого вызова крайние сроки, отмену и данные.

#### Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions

Одно из преимуществ использования контекста — это возможность передачи данных на протяжении обработки задачи через несколько промежуточных слоев.

Это позволяет сделать функция WithValue из пакета context. Однако стоит взвешенно использовать эту функциональность. 

Если передавать в контексте опциональные аргументы функций, то это усложняет документирование в функциях. И может стать неявным, что функция ожидает какое-либо значение из контекста. Это делает API непонятным, усложняет чтение и поддержку кода, что в дальнейшем может привести к ошибкам.

Рекомендовано избегать хранения данных в контексте, если они могут быть переданы обычным аргументом в функции.

В контексте правильно передавать только значения, которые пересекают границы процессов и живут от начала и до конца обработки задачи. Например идентификатор пользователя или запроса для идентификации задачи при логировании.


#### Реализации контекста

В пакете имеются следующие типы, реализующие интерфейс Context:
- emptyCtx
- cancelCtx
- timerCtx
- valueCtx
- stopCtx
- afterFuncCtx
- withoutCancelCtx
- backgroundCtx
- todoCtx


Большинство типов ассоциированы с функциями, создающими контекст.

Тип emptyCtx встроен в типы backgroundCtx и todoCtx.

Тип cancelCtx встроен в типы timerCtx и afterFuncCtx.

![image](https://github.com/mcei/doc/assets/57292616/9a5fb7d6-b018-4bf3-9f45-2cc21a652889)


#### Embedding

Go предлагает механизм встраивания (embedding) в качестве альтернативы традиционному механизму наследования.

Разберем пример эмбеддинга из библиотеки Context.

`type backgroundCtx struct{ emptyCtx }`

Тип emptyCtx встроен в тип backgroundCtx и является для него основой.

У emptyCtx [реализованы]([url](https://github.com/golang/go/blob/master/src/context/context.go#L179-L193)) методы Deadline(), Done(), Err(), Value(), а backgroundCtx реализует лишь свой метод String. При этом, эмбеддинг emptyCtx делает все его методы доступными для backgroundCtx.


#### context.AfterFunc

AfterFunc принимает функцию (f), которая будет выполнена после того, как контекст будет отменен (в том числе после истечения таймаута). Если контекст уже в состоянии Done, то функция будет запущена сразу же.

```go
func AfterFunc(ctx Context, f func()) (stop func() bool) {
	a := &afterFuncCtx{
		f: f,
	}
	a.cancelCtx.propagateCancel(ctx, a)
	return func() bool {
		stopped := false
		a.once.Do(func() {
			stopped = true
		})
		if stopped {
			a.cancel(true, Canceled, nil)
		}
		return stopped
	}
}
```

Выполнение f происходит в отдельной горутине. Множественные вызовы AfterFunc выполняются независимо друг отдруга.

AfterFunc возвращает stop-функцию.

Вызов stop-функции разрывает ассоциацию f с контекстом.

stop-функция возвращает false в случаях если контекст уже в состоянии Done и f уже была запущена или f уже была остановлена.
stop-функция возвращает true, если был предотвращен вызов f.

stop-функция не дожидается пока f будет завершена, поэтому если нужно контролировать состояние, то лучше явно коммуницировать с f.

#### sync.Once

Рассмотрим использование sync.Once.Do в context.AfterFunc

AfterFuncCtx встраивает объект sync.Once

```go
type afterFuncCtx struct {
	cancelCtx
	once sync.Once
	f    func()
}
```
Функция once.Do вызывает функцию f только в том случае, если она вызывается в первый раз для текущего инстанса Once.
Если once.Do(f) вызывается несколько раз, то только первый вызов выполнит f.

То есть once.Do(f) либо вызывает f, либо предотвращает ее повторный вызов.

Так сделано для того, чтобы при отмене контекста из разных горутин, AfterFunc выполнилась только единожды.

#### Reusable closed channel

Разберем интересный прием использования закрытого канала в пакете context.

```go
var closedchan = make(chan struct{})

func init() {
	close(closedchan)
}
```

При инициализации пакета создается переменная closedchan. 

Чтобы закрыть канал, используется функция `init()`. Это своеобразный механизм, который сообщает компилятору какой код должен быть выполнен перед импортом пакета. Код содержащийся в `init()` исполняется только один раз.

Далее закрытый канал используется для изменения и проверки состояния Done при отмене контекста.

```go
if done == closedchan {
	...
}
```
